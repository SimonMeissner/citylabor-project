library(raster)
# read jointly created vegetables table
plants <- read.table('plants.csv', sep = ',', header = T)
# TEMPORARILY excluding non-usable data
plants <- plants[,1:6]
colnames(plants) <- c('name', 'space', 'when_to_plant', 'min_grow_t', 'max_grow_t', 'when_to_harvest')
# mean survival time (discussion required)
plants$time <- as.numeric(( plants$max_grow_t + plants$min_grow_t ) / 2)
plants_mut <- mutate(plants, space = ifelse((space < 77), "LT77", "OV77"), #77 is mean space
space = factor(space))
# Random Forest Ensemble Model for Prob. of Survival
r_fit <- ranger(Surv(time) ~ space + min_grow_t + max_grow_t,
data = plants_mut,
mtry = 2,
importance = "permutation",
splitrule = "extratrees",
verbose = TRUE)
death_times <- r_fit$unique.death.times
surv_prob <- data.frame(r_fit$survival)
avg_prob <- sapply(surv_prob,mean)
# run all together ...
### start
plot(r_fit$unique.death.times,r_fit$survival[1,],
type = "l",
ylim = c(0,1),
col = "red",
xlab = "Days",
ylab = "survival",
main = "Patient Survival Curves")
cols <- colors()
for (n in sample(c(2:dim(plants_mut)[1]), 20)){
lines(r_fit$unique.death.times, r_fit$survival[n,], type = "l", col = cols[n])
}
lines(death_times, avg_prob, lwd = 2)
legend(500, 0.7, legend = c('Average = black'))
### end
vi <- data.frame(sort(round(r_fit$variable.importance, 4), decreasing = TRUE))
names(vi) <- "importance"
head(vi)
# Area under ROC
cat("Prediction Error = 1 - Harrell's c-index = ", r_fit$prediction.error)
##############
# using user data
xy <- c(51.95031, 7.55539)
kg <- raster('climate.tif')
user_clim <- extract(kg, xy)
#transform climate -- missing
size = 77 #squared inches size #user defined
wtp = "03.07.2021" #user defined
wth = "03.09.2021" #user defined
wtp <- as.Date(wtp, '%d.%m.%Y')
wth <- as.Date(wth, '%d.%m.%Y')
gt = as.integer(wth - wtp)
dt <- c()
for (i in 1:length(death_times)){
dt[i] <- abs(death_times[i] - gt)
}
min_dt <- min(dt)
for (i in 1:length(death_times)){
if (dt[i] == min(dt)){
item = i
}
}
wtp = as.integer(format(wtp, "%m"))
wth = as.integer(format(wth, "%m"))
#final filtering
f <- surv_prob[,item]
ls <- c()
for ( i in 1:length(f)){
if (f[i] > 0.6){
ls <- c(ls, i)
}
}
ls
nls <- c()
for ( i in ls){
if (grepl(wtp, plants[i, 3]) == 1 & grepl(wth, plants[i, 6]) == 1) {
nls <- c(nls, i)
}
}
nls
prd <- plants[nls,]
prd$surv_p <- round(surv_prob[nls, item], 2)*100
prd <- prd[which(prd$min_grow_t <= gt + 15 & prd$max_grow_t >= gt - 15), ]
prd <- prd[which(prd$space <= size + 50 ),]
if ( nrow(prd) == 0){
print("Sorry, no recommendations for you. Please try other dates.")
}else{
for (i in 1:nrow(prd)){
cat(
"We recommend you ",
prd[i, 1],
"with a",
as.character(prd[i,'surv_p']),
"% chance of success!",
"You're harvesting between", prd[i, 4], "and", prd[i, 5], "days, approximatedly",
"\n\n"
)
}
}
library(leaflet)
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
View(plant_data)
runApp()
runApp()
View(plant_data)
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
summary(draw1)
summary(draw2)
plant_data <- read.csv("src/20211214-plants-scraped.csv", header=TRUE) # Load test plant data
# https://shiny.rstudio.com/articles/reactivity-overview.html
# install R packages
# load R packages
suppressPackageStartupMessages(library(shiny))
suppressPackageStartupMessages(library(shinythemes))
suppressPackageStartupMessages(library(leaflet))
suppressPackageStartupMessages(library(leaflet.extras))
suppressPackageStartupMessages(library(survival))
suppressPackageStartupMessages(library(ranger))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(raster))
plant_data <- read.csv("src/20211214-plants-scraped.csv", header=TRUE) # Load test plant data
# UI -------------------------------------------------------------------------------------------
ui <- fluidPage(theme = shinytheme("cerulean"),
tags$head(includeHTML(("www/geolocation.html"))),
navbarPage(
title = "Urban Garden App",
id = "navbar",
# Page1, used as a welcome landing page with descriptions and redirecting features for the user
tabPanel( title = "Welcome", value = "tab1",
mainPanel(
h1("Under Construction!",style = "font-weight: 500; color: red"), #Under Construction sign
h1("Welcome"),
p("This is the landing page of our webapp build in R-Shiny!
It could be used to describe our app and suggests the user
to use one of the two options."),
actionButton("redirect1", "What to plant"),
actionButton("redirect2", "When to plant"),
p("By clicking one of the options the user gets redirected to the different pages"),
h1("Testing Location api",style = "font-weight: 500; color: red"),
verbatimTextOutput("location")
)
), # end Page1
# Page2, used for providing the "When to plant" service
tabPanel( title = "What to plant!", value = "tab2",
sidebarLayout(
sidebarPanel(
tags$h3("What can I plant?"),
tags$h5(tags$b("Location: ")),
leafletOutput("map1"), #displaying map
textInput("space", "How much space is available:", ""),
# Select growth range
dateRangeInput("growthrange", "Select timeframe from planting to harvesting", start = NULL, end = NULL,
min = "2021-01-01", max = "2030-01-01", startview =  "year", weekstart = "1"),
#submit button
actionButton(inputId = "data1", label = "Submit"),
),
# sidebarPanel
mainPanel( # mainPanel used for outputting results
h1("Under Construction!",style = "font-weight: 500; color: red"), #Under Construction sign
h2("Results:"),
h4("lists possible plants ordered by success rate!"),
verbatimTextOutput("plants"),
) # mainPanel
) # sidebarLayout
), # end Page2
# Page3, used for providing the "What to plant" service
tabPanel( title = "When to plant!", value = "tab3",
sidebarLayout(
sidebarPanel(
tags$h3("When can I plant?"),
tags$h5(tags$b("Location: ")),
leafletOutput("map2"), #displaying map
# Select type of plant
selectInput(inputId = "plant", label = strong("Select Plant:"), choices = unique(plant_data$plant_name)),
# submit button
actionButton(inputId = "data2",label = "Submit"),
), # sidebarPanel
mainPanel( # mainPanel used for outputting results
h1("Under Construction!",style = "font-weight: 500; color: red"), #Under Construction sign
h2("Results:"),
h4("returns possibly planting and harvest times for your plant in addition to the required space"),
tableOutput("timesAndSpace"),
) # mainPanel
) # sidebarLayout
) # end Page3
) # navbarPage
) # fluidPage
# Server --------------------------------------------------------------------------------
server <- function(input, output, session) {
#only submit data when submit button is pressed
data1 <- eventReactive(input$data1, { c(input$space,input$growthrange)})
data2 <- eventReactive(input$data2, { filter_wtp(plant= input$plant, space=9000, clim="Dfa") })
#
# outputs of the two pages
# page what to plant
output$plants <- renderText( data1())
# page when to plant
output$timesAndSpace <- renderTable( data2(), rownames = TRUE)
#
#location api request
latLongStatus <- reactive({c(input$lat, input$long, input$geolocation)})
output$location <- renderText( latLongStatus())
#
#map section
#middleware to avoid duplicate code
mapdata <- reactive({
leaflet() %>%
addTiles(options = tileOptions(opacity = 0.8)) %>%
setView(7.633763,51.97587, zoom = 4) %>%
addDrawToolbar(
polylineOptions = FALSE,
polygonOptions = FALSE,
rectangleOptions = FALSE,
circleOptions = FALSE,
markerOptions = TRUE,
circleMarkerOptions = FALSE,
singleFeature = TRUE,
editOptions = editToolbarOptions()
)
})
#save every drawn marker from map1
observeEvent(input$map1_draw_new_feature, {
draw1  <- input$map1_draw_new_feature
print(draw1$geometry$coordinates[[1]])
print(draw1$geometry$coordinates[[2]])
summary(draw1)
})
#save every drawn marker from map2
observeEvent(input$map2_draw_new_feature, {
draw2  <- input$map2_draw_new_feature
print(draw2$geometry$coordinates[[1]])
print(draw2$geometry$coordinates[[2]])
summary(draw2)
})
#map on page "what to plant"
output$map1 <- renderLeaflet({ mapdata() })
#map on page "when to plant"
output$map2 <- renderLeaflet({ mapdata() })
#
#map section end
#handle redirect
observeEvent(input$redirect1,{
updateNavbarPage(session,"navbar",selected = "tab2") #redirect to what to plant
})
observeEvent(input$redirect2, {
updateNavbarPage(session,"navbar",selected = "tab3") #redirect to when to plant
})
#
# get climate from user depending on location
climate <- function(rst, x, y) {
xy <- data.frame(x = c(x), y = c(y))
kg <- raster(rst)
n_clim <- extract(kg, xy)
classif <- c('Af', 'Am', 'Aw', 'BWh', 'BWk', 'BSh', 'BSk', 'Csa', 'Csb', 'Cwa', 'Cwb', 'Cwc',
'Cfa', 'Cfb', 'Cfc', 'Dsa', 'Dsb', 'Dsc', 'Dsd', 'Dwa', 'Dwb', 'Dwc', 'Dwd', 'Dfa',
'Dfb', 'Dfc', 'Dfd', 'ET', 'EF')
user_clim <- classif[n_clim]
return (user_clim)
}
########### FILTER WHEN TO PLANT ##########
number_of_rows_in_dataset <- nrow(plant_data)
range <- 1:number_of_rows_in_dataset
Months<-c("January","February","March","April","May","June","July","August","September","October","November","December")
filter_wtp <- function(plant, space, clim){
output_array <- vector()
for(n in range){
if(plant == plant_data$plant_name[n]){
if(plant_data$required_space[n]>space){
return("You do not have enough space")
}
if(plant_data$required_space[n]<=space && plant_data$climate[n] == clim) {
when_to_plant <- plant_data$when_to_plant[n]
when_to_plant <- unlist(strsplit(when_to_plant, ","))
when_to_plant <- as.numeric(when_to_plant)
for(i in when_to_plant){
x <- c("You can plant in ", Months[i])
output_array <- append(output_array, x)
cat("You can plant in", Months[i], "\n\n")
}
}
}
}
print(output_array)
return(output_array)
}
}
# Create Shiny object
shinyApp(ui = ui, server = server)
summary(draw1)
runApp()
View(ui)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
app.R
run(app.R)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(server)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(plant_data)
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
<<<<<<< HEAD
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
=======
shiny::runApp()
>>>>>>> 1c4410f0ab59f3f50af52b69f84f5487be51e551
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
install.packages("DT")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
